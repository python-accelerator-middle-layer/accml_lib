from abc import ABCMeta, abstractmethod
from typing import Sequence, Union

from accml.core.model.command import Command, ReadCommand


class ControllerInterface(metaclass=ABCMeta):
    """ """

    @abstractmethod
    async def continuous(
        self,
        *,
        read_commands: Sequence[ReadCommand],
        set_commands: Sequence[Command],
        n_steps: Union[int, None] = None,
    ):
        """
        Args:
            read_commands: commands to retrieve the observed positions
            set_commands:  commands to set the actuators. Note that
                           a copy of the command will be made and the
                           value will be adapted
            n_steps: if set to None, run forever, otherwise run
                     maximum number of steps and stop then

        Discussion:
            Should "read commands" and "set commands" be made
            available already at init?

            Read commands tell the controller how to get to an
            "observable" state. "set_commands" allow the controller
            to e.g. probe the used measurement/cmd execution engine
            if these commands are understood and available.

            The commands actually set will be typically produced by
            the "policy". An alternate way would be that the policy
            changes the step to be taken. The commands to be executed
            are then generated by the controller.

        """
        raise NotImplementedError("use derived class instead")


__all__ = ["ControllerInterface"]
